import { Connection, PublicKey, TransactionInstruction } from '@solana/web3.js';
import { ValidDepthSizePair } from '../constants';
import { MerkleTreeProof } from '../merkle-tree';
/**
 * Helper function that adds proof nodes to a TransactionInstruction
 * by adding extra keys to the transaction
 */
export declare function addProof(instruction: TransactionInstruction, nodeProof: Buffer[]): TransactionInstruction;
/**
 * Helper function for {@link createInitEmptyMerkleTreeInstruction}
 *
 * @param merkleTree
 * @param authority
 * @param depthSizePair
 * @returns
 */
export declare function createInitEmptyMerkleTreeIx(merkleTree: PublicKey, authority: PublicKey, depthSizePair: ValidDepthSizePair): TransactionInstruction;
/**
 * (Devnet only) Helper function for {@link createPrepareBatchMerkleTreeInstruction}
 * @param merkleTree
 * @param authority
 * @param depthSizePair
 * @returns
 */
export declare function prepareTreeIx(merkleTree: PublicKey, authority: PublicKey, depthSizePair: ValidDepthSizePair): TransactionInstruction;
/**
 * (Devnet only) Helper function for {@link createAppendCanopyNodesInstruction}
 * @param merkleTree
 * @param authority
 * @param canopyNodes
 * @param startIndex
 * @returns
 */
export declare function createAppendCanopyNodesIx(merkleTree: PublicKey, authority: PublicKey, canopyNodes: ArrayLike<number>[] | Buffer[], startIndex: number): TransactionInstruction;
/**
 * (Devnet only) Helper function for {@link createInitPreparedTreeWithRootInstruction}
 * @param merkleTree
 * @param authority
 * @param root
 * @param rightmostLeaf
 * @param rightmostIndex
 * @param proof
 * @returns
 */
export declare function createInitPreparedTreeWithRootIx(merkleTree: PublicKey, authority: PublicKey, root: ArrayLike<number> | Buffer, rightmostLeaf: ArrayLike<number> | Buffer, rightmostIndex: number, proof: Buffer[]): TransactionInstruction;
/**
 * Helper function for {@link createReplaceLeafInstruction}
 * @param merkleTree
 * @param authority
 * @param proof
 * @param newLeaf
 * @returns
 */
export declare function createReplaceIx(merkleTree: PublicKey, authority: PublicKey, newLeaf: Buffer, proof: MerkleTreeProof): TransactionInstruction;
/**
 * Helper function for {@link createAppendInstruction}
 * @param merkleTree
 * @param authority
 * @param newLeaf
 * @returns
 */
export declare function createAppendIx(merkleTree: PublicKey, authority: PublicKey, newLeaf: ArrayLike<number> | Buffer): TransactionInstruction;
/**
 * Helper function for {@link createTransferAuthorityIx}
 * @param merkleTree
 * @param authority
 * @param newAuthority
 * @returns
 */
export declare function createTransferAuthorityIx(merkleTree: PublicKey, authority: PublicKey, newAuthority: PublicKey): TransactionInstruction;
/**
 * Helper function for {@link createVerifyLeafInstruction}
 * @param merkleTree
 * @param proof
 * @returns
 */
export declare function createVerifyLeafIx(merkleTree: PublicKey, proof: MerkleTreeProof): TransactionInstruction;
/**
 * Helper function for creating the {@link ConcurrentMerkleTreeAccount}.
 * It is best to use this method to initialize a {@link ConcurrentMerkleTreeAccount}
 * because these accounts can be quite large, and over the limit for what you
 * can allocate via CPI.
 * @param connection
 * @param merkleTree
 * @param payer
 * @param depthSizePair
 * @param canopyDepth
 * @returns
 */
export declare function createAllocTreeIx(connection: Connection, merkleTree: PublicKey, payer: PublicKey, depthSizePair: ValidDepthSizePair, canopyDepth: number): Promise<TransactionInstruction>;
/**
 * Helper function for {@link createCloseEmptyTreeInstruction}.
 * @param merkleTree
 * @param authority
 * @param recipient
 * @returns
 */
export declare function createCloseEmptyTreeIx(merkleTree: PublicKey, authority: PublicKey, recipient: PublicKey): TransactionInstruction;
//# sourceMappingURL=index.d.ts.map