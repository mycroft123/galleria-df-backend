"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addProof = addProof;
exports.createInitEmptyMerkleTreeIx = createInitEmptyMerkleTreeIx;
exports.prepareTreeIx = prepareTreeIx;
exports.createAppendCanopyNodesIx = createAppendCanopyNodesIx;
exports.createInitPreparedTreeWithRootIx = createInitPreparedTreeWithRootIx;
exports.createReplaceIx = createReplaceIx;
exports.createAppendIx = createAppendIx;
exports.createTransferAuthorityIx = createTransferAuthorityIx;
exports.createVerifyLeafIx = createVerifyLeafIx;
exports.createAllocTreeIx = createAllocTreeIx;
exports.createCloseEmptyTreeIx = createCloseEmptyTreeIx;
const web3_js_1 = require("@solana/web3.js");
const accounts_1 = require("../accounts");
const constants_1 = require("../constants");
const generated_1 = require("../generated");
/**
 * Helper function that adds proof nodes to a TransactionInstruction
 * by adding extra keys to the transaction
 */
function addProof(instruction, nodeProof) {
    instruction.keys = instruction.keys.concat(nodeProof.map(node => {
        return {
            isSigner: false,
            isWritable: false,
            pubkey: new web3_js_1.PublicKey(node),
        };
    }));
    return instruction;
}
/**
 * Helper function for {@link createInitEmptyMerkleTreeInstruction}
 *
 * @param merkleTree
 * @param authority
 * @param depthSizePair
 * @returns
 */
function createInitEmptyMerkleTreeIx(merkleTree, authority, depthSizePair) {
    return (0, generated_1.createInitEmptyMerkleTreeInstruction)({
        authority: authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, depthSizePair);
}
/**
 * (Devnet only) Helper function for {@link createPrepareBatchMerkleTreeInstruction}
 * @param merkleTree
 * @param authority
 * @param depthSizePair
 * @returns
 */
function prepareTreeIx(merkleTree, authority, depthSizePair) {
    return (0, generated_1.createPrepareBatchMerkleTreeInstruction)({
        authority: authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, depthSizePair);
}
/**
 * (Devnet only) Helper function for {@link createAppendCanopyNodesInstruction}
 * @param merkleTree
 * @param authority
 * @param canopyNodes
 * @param startIndex
 * @returns
 */
function createAppendCanopyNodesIx(merkleTree, authority, canopyNodes, startIndex) {
    return (0, generated_1.createAppendCanopyNodesInstruction)({
        authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, {
        canopyNodes: canopyNodes.map(node => Array.from(node)),
        startIndex,
    });
}
/**
 * (Devnet only) Helper function for {@link createInitPreparedTreeWithRootInstruction}
 * @param merkleTree
 * @param authority
 * @param root
 * @param rightmostLeaf
 * @param rightmostIndex
 * @param proof
 * @returns
 */
function createInitPreparedTreeWithRootIx(merkleTree, authority, root, rightmostLeaf, rightmostIndex, proof) {
    return (0, generated_1.createInitPreparedTreeWithRootInstruction)({
        anchorRemainingAccounts: proof.map(node => {
            return {
                isSigner: false,
                isWritable: false,
                pubkey: new web3_js_1.PublicKey(node),
            };
        }),
        authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, {
        rightmostIndex,
        rightmostLeaf: Array.from(rightmostLeaf),
        root: Array.from(root),
    });
}
/**
 * Helper function for {@link createReplaceLeafInstruction}
 * @param merkleTree
 * @param authority
 * @param proof
 * @param newLeaf
 * @returns
 */
function createReplaceIx(merkleTree, authority, newLeaf, proof) {
    return addProof((0, generated_1.createReplaceLeafInstruction)({
        authority: authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, {
        index: proof.leafIndex,
        newLeaf: Array.from(newLeaf),
        previousLeaf: Array.from(proof.leaf),
        root: Array.from(proof.root),
    }), proof.proof);
}
/**
 * Helper function for {@link createAppendInstruction}
 * @param merkleTree
 * @param authority
 * @param newLeaf
 * @returns
 */
function createAppendIx(merkleTree, authority, newLeaf) {
    return (0, generated_1.createAppendInstruction)({
        authority: authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, {
        leaf: Array.from(newLeaf),
    });
}
/**
 * Helper function for {@link createTransferAuthorityIx}
 * @param merkleTree
 * @param authority
 * @param newAuthority
 * @returns
 */
function createTransferAuthorityIx(merkleTree, authority, newAuthority) {
    return (0, generated_1.createTransferAuthorityInstruction)({
        authority: authority,
        merkleTree,
    }, {
        newAuthority,
    });
}
/**
 * Helper function for {@link createVerifyLeafInstruction}
 * @param merkleTree
 * @param proof
 * @returns
 */
function createVerifyLeafIx(merkleTree, proof) {
    return addProof((0, generated_1.createVerifyLeafInstruction)({
        merkleTree,
    }, {
        index: proof.leafIndex,
        leaf: Array.from(proof.leaf),
        root: Array.from(proof.root),
    }), proof.proof);
}
/**
 * Helper function for creating the {@link ConcurrentMerkleTreeAccount}.
 * It is best to use this method to initialize a {@link ConcurrentMerkleTreeAccount}
 * because these accounts can be quite large, and over the limit for what you
 * can allocate via CPI.
 * @param connection
 * @param merkleTree
 * @param payer
 * @param depthSizePair
 * @param canopyDepth
 * @returns
 */
function createAllocTreeIx(connection, merkleTree, payer, depthSizePair, canopyDepth) {
    return __awaiter(this, void 0, void 0, function* () {
        const requiredSpace = (0, accounts_1.getConcurrentMerkleTreeAccountSize)(depthSizePair.maxDepth, depthSizePair.maxBufferSize, canopyDepth !== null && canopyDepth !== void 0 ? canopyDepth : 0);
        return web3_js_1.SystemProgram.createAccount({
            fromPubkey: payer,
            lamports: yield connection.getMinimumBalanceForRentExemption(requiredSpace),
            newAccountPubkey: merkleTree,
            programId: generated_1.PROGRAM_ID,
            space: requiredSpace,
        });
    });
}
/**
 * Helper function for {@link createCloseEmptyTreeInstruction}.
 * @param merkleTree
 * @param authority
 * @param recipient
 * @returns
 */
function createCloseEmptyTreeIx(merkleTree, authority, recipient) {
    return (0, generated_1.createCloseEmptyTreeInstruction)({
        authority,
        merkleTree,
        recipient,
    });
}
//# sourceMappingURL=index.js.map