"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertCMTProperties = assertCMTProperties;
const node_assert_1 = require("node:assert");
const anchor_1 = require("@coral-xyz/anchor");
const nodewallet_1 = __importDefault(require("@coral-xyz/anchor/dist/cjs/nodewallet"));
const web3_js_1 = require("@solana/web3.js");
const src_1 = require("../../src");
const merkle_tree_1 = require("../../src/merkle-tree");
const utils_1 = require("../utils");
function assertCMTProperties(onChainCMT, expectedMaxDepth, expectedMaxBufferSize, expectedAuthority, expectedRoot, expectedCanopyDepth, expectedIsBatchInitialized = false) {
    (0, node_assert_1.strict)(onChainCMT.getMaxDepth() === expectedMaxDepth, `Max depth does not match ${onChainCMT.getMaxDepth()}, expected ${expectedMaxDepth}`);
    (0, node_assert_1.strict)(onChainCMT.getMaxBufferSize() === expectedMaxBufferSize, `Max buffer size does not match ${onChainCMT.getMaxBufferSize()}, expected ${expectedMaxBufferSize}`);
    (0, node_assert_1.strict)(onChainCMT.getAuthority().equals(expectedAuthority), 'Failed to write auth pubkey');
    (0, node_assert_1.strict)(onChainCMT.getCurrentRoot().equals(expectedRoot), 'On chain root does not match root passed in instruction');
    if (expectedCanopyDepth) {
        (0, node_assert_1.strict)(onChainCMT.getCanopyDepth() === expectedCanopyDepth, 'On chain canopy depth does not match expected canopy depth');
    }
    (0, node_assert_1.strict)(onChainCMT.getIsBatchInitialized() === expectedIsBatchInitialized, 'On chain isBatchInitialized does not match expected value');
}
describe('ConcurrentMerkleTreeAccount tests', () => {
    // Configure the client to use the local cluster.
    let offChainTree;
    let cmtKeypair;
    let payerKeypair;
    let payer;
    let connection;
    let provider;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        payerKeypair = web3_js_1.Keypair.generate();
        payer = payerKeypair.publicKey;
        connection = new web3_js_1.Connection('http://127.0.0.1:8899', {
            commitment: 'confirmed',
        });
        const wallet = new nodewallet_1.default(payerKeypair);
        provider = new anchor_1.AnchorProvider(connection, wallet, {
            commitment: connection.commitment,
            skipPreflight: true,
        });
        yield provider.connection.confirmTransaction(yield provider.connection.requestAirdrop(payer, 1e10), 'confirmed');
    }));
    describe('Can deserialize a CMTAccount from an on-chain CMT with a single leaf', () => {
        const MAX_SIZE = 64;
        const MAX_DEPTH = 14;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, payerKeypair, 1, {
                maxBufferSize: MAX_SIZE,
                maxDepth: MAX_DEPTH,
            });
        }));
        it('Interpreted on-chain fields correctly', () => __awaiter(void 0, void 0, void 0, function* () {
            const cmt = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmtKeypair.publicKey, 'confirmed');
            yield assertCMTProperties(cmt, MAX_DEPTH, MAX_SIZE, payer, offChainTree.root);
        }));
    });
    describe('Test deserialization for available depth-size pairs', () => {
        it('Test all pairs', () => __awaiter(void 0, void 0, void 0, function* () {
            for (const depthSizePair of src_1.ALL_DEPTH_SIZE_PAIRS) {
                // Airdrop enough SOL to cover tree creation
                const size = (0, src_1.getConcurrentMerkleTreeAccountSize)(depthSizePair.maxDepth, depthSizePair.maxBufferSize);
                const rent = yield connection.getMinimumBalanceForRentExemption(size, 'confirmed');
                const airdropId = yield connection.requestAirdrop(payer, rent + 5000 * 2);
                yield connection.confirmTransaction(airdropId, 'confirmed');
                // Create on chain tree
                cmtKeypair = yield (0, utils_1.createEmptyTreeOnChain)(provider, payerKeypair, depthSizePair);
                const cmt = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmtKeypair.publicKey, 'confirmed');
                // Verify it was initialized correctly
                yield assertCMTProperties(cmt, depthSizePair.maxDepth, depthSizePair.maxBufferSize, payer, (0, merkle_tree_1.emptyNode)(depthSizePair.maxDepth));
            }
        }));
    });
    describe('Test deserialization for canopy size for depth 30 tree', () => {
        it('Test all pairs', () => __awaiter(void 0, void 0, void 0, function* () {
            const maxDepth = 30;
            const maxBufferSize = 2048;
            for (let canopyDepth = 1; canopyDepth <= 14; canopyDepth++) {
                // Airdrop enough SOL to cover tree creation
                const size = (0, src_1.getConcurrentMerkleTreeAccountSize)(maxDepth, maxBufferSize, canopyDepth);
                const rent = yield connection.getMinimumBalanceForRentExemption(size, 'confirmed');
                const airdropId = yield connection.requestAirdrop(payer, rent + 5000 * 2);
                yield connection.confirmTransaction(airdropId, 'confirmed');
                // Create on chain tree
                cmtKeypair = yield (0, utils_1.createEmptyTreeOnChain)(provider, payerKeypair, { maxBufferSize, maxDepth }, canopyDepth);
                const cmt = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmtKeypair.publicKey, 'confirmed');
                // Verify it was initialized correctly
                yield assertCMTProperties(cmt, maxDepth, maxBufferSize, payer, (0, merkle_tree_1.emptyNode)(maxDepth), canopyDepth);
            }
        }));
    });
    describe('Can deserialize an existing CMTAccount from a real on-chain CMT created before the is_batch_initialized field was introduced inplace of the first byte of _padding', () => {
        it('Interpreted on-chain fields correctly', () => __awaiter(void 0, void 0, void 0, function* () {
            // The account data was generated by running:
            //      $ solana account 27QMkDMpBoAhmWj6xxQNYdqXZL5nnC8tkZcEtkNxCqeX \
            //                       --output-file tests/fixtures/pre-batch-init-tree-account.json \
            //                       --output json
            const deployedAccount = new web3_js_1.PublicKey('27QMkDMpBoAhmWj6xxQNYdqXZL5nnC8tkZcEtkNxCqeX');
            const cmt = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, deployedAccount, 'confirmed');
            const expectedMaxDepth = 10;
            const expectedMaxBufferSize = 32;
            const expectedCanopyDepth = 0;
            const expectedAuthority = new web3_js_1.PublicKey('BFNT941iRwYPe2Js64dTJSoksGCptWAwrkKMaSN73XK2');
            const expectedRoot = new web3_js_1.PublicKey('83UjseEuEgxyVyDTmrJCQ9QbeksdRZ7KPDZGQYc5cAgF').toBuffer();
            const expectedIsBatchInitialized = false;
            yield assertCMTProperties(cmt, expectedMaxDepth, expectedMaxBufferSize, expectedAuthority, expectedRoot, expectedCanopyDepth, expectedIsBatchInitialized);
        }));
    });
});
//# sourceMappingURL=concurrentMerkleTreeAccount.test.js.map