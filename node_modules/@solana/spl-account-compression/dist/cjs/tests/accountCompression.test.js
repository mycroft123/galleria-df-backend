"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_assert_1 = require("node:assert");
const anchor_1 = require("@coral-xyz/anchor");
const nodewallet_1 = __importDefault(require("@coral-xyz/anchor/dist/cjs/nodewallet"));
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = require("bn.js");
const crypto = __importStar(require("crypto"));
const src_1 = require("../src");
const merkle_tree_1 = require("../src/merkle-tree");
const concurrentMerkleTreeAccount_test_1 = require("./accounts/concurrentMerkleTreeAccount.test");
const utils_1 = require("./utils");
// eslint-disable-next-line no-empty
describe('Account Compression', () => {
    // Configure the client to use the local cluster.
    let offChainTree;
    let cmtKeypair;
    let cmt;
    let payerKeypair;
    let payer;
    let connection;
    let provider;
    const MAX_SIZE = 64;
    const MAX_DEPTH = 14;
    const DEPTH_SIZE_PAIR = {
        maxBufferSize: MAX_SIZE,
        maxDepth: MAX_DEPTH,
    };
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        payerKeypair = web3_js_1.Keypair.generate();
        payer = payerKeypair.publicKey;
        connection = new web3_js_1.Connection('http://127.0.0.1:8899', {
            commitment: 'confirmed',
        });
        const wallet = new nodewallet_1.default(payerKeypair);
        provider = new anchor_1.AnchorProvider(connection, wallet, {
            commitment: connection.commitment,
            skipPreflight: true,
        });
        yield provider.connection.confirmTransaction(yield provider.connection.requestAirdrop(payer, 1e10), 'confirmed');
    }));
    describe('Having prepared a tree without canopy', () => {
        const depth = 3;
        const size = 8;
        const canopyDepth = 0;
        const leaves = [
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
        ];
        let anotherKeyPair;
        let another;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            const cmtKeypair = yield (0, utils_1.prepareTree)({
                canopyDepth,
                depthSizePair: {
                    maxBufferSize: size,
                    maxDepth: depth,
                },
                payer: payerKeypair,
                provider,
            });
            cmt = cmtKeypair.publicKey;
            anotherKeyPair = web3_js_1.Keypair.generate();
            another = anotherKeyPair.publicKey;
            yield provider.connection.confirmTransaction(yield provider.connection.requestAirdrop(another, 1e10), 'confirmed');
        }));
        it('Should be able to finalize the tree', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const canopyDepth = 0;
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            (0, concurrentMerkleTreeAccount_test_1.assertCMTProperties)(splCMT, depth, size, payer, root, canopyDepth, true);
            (0, node_assert_1.strict)(splCMT.getBufferSize() == 1, 'Buffer size does not match');
        }));
        it('Should fail to append canopy node for a tree without canopy', () => __awaiter(void 0, void 0, void 0, function* () {
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [crypto.randomBytes(32)], 0);
            try {
                yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Canopy appending should have failed to execute for a tree without canopy');
            }
            catch (_a) { }
        }));
        it('Should fail to finalize the tree with another payer authority', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, another, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            try {
                yield (0, utils_1.execute)(provider, [finalize], [anotherKeyPair]);
                (0, node_assert_1.strict)(false, 'Finalizing with another payer should have failed');
            }
            catch (_a) { }
        }));
        it('Should fail to finalize the tree with a wrong proof', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            // Replace valid proof with random bytes so it is wrong
            const proof = merkleTreeRaw.getProof(leaves.length - 1);
            proof.proof = proof.proof.map(_ => {
                return crypto.randomBytes(32);
            });
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, proof.proof);
            try {
                yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Finalizing with a wrong proof should have failed');
            }
            catch (_a) { }
        }));
        it('Should fail to double finalize the tree', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
            try {
                yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Double finalizing should have failed');
            }
            catch (_a) { }
        }));
        it('Should be able to close a prepared tree', () => __awaiter(void 0, void 0, void 0, function* () {
            let payerInfo = yield provider.connection.getAccountInfo(payer, 'confirmed');
            let treeInfo = yield provider.connection.getAccountInfo(cmt, 'confirmed');
            const payerLamports = payerInfo.lamports;
            const treeLamports = treeInfo.lamports;
            const closeIx = (0, src_1.createCloseEmptyTreeIx)(cmt, payer, payer);
            yield (0, utils_1.execute)(provider, [closeIx], [payerKeypair]);
            payerInfo = yield provider.connection.getAccountInfo(payer, 'confirmed');
            const finalLamports = payerInfo.lamports;
            (0, node_assert_1.strict)(finalLamports === payerLamports + treeLamports - 5000, 'Expected payer to have received the lamports from the closed tree account');
            treeInfo = yield provider.connection.getAccountInfo(cmt, 'confirmed');
            (0, node_assert_1.strict)(treeInfo === null, 'Expected the merkle tree account info to be null');
        }));
    });
    describe('Having prepared a tree with canopy', () => {
        const depth = 3;
        const size = 8;
        const canopyDepth = 2;
        const leaves = [
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
            crypto.randomBytes(32),
        ];
        let anotherKeyPair;
        let another;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            const cmtKeypair = yield (0, utils_1.prepareTree)({
                canopyDepth,
                depthSizePair: {
                    maxBufferSize: size,
                    maxDepth: depth,
                },
                payer: payerKeypair,
                provider,
            });
            cmt = cmtKeypair.publicKey;
            anotherKeyPair = web3_js_1.Keypair.generate();
            another = anotherKeyPair.publicKey;
            yield provider.connection.confirmTransaction(yield provider.connection.requestAirdrop(another, 1e10), 'confirmed');
        }));
        it('Should be able to append a single canopy node', () => __awaiter(void 0, void 0, void 0, function* () {
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [crypto.randomBytes(32)], 0);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
        }));
        it('Should be able to append a single canopy node at the index more then 0', () => __awaiter(void 0, void 0, void 0, function* () {
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [crypto.randomBytes(32)], 1);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
        }));
        it('Should be able to append several canopy nodes at the start of the node leaves', () => __awaiter(void 0, void 0, void 0, function* () {
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [crypto.randomBytes(32), crypto.randomBytes(32)], 0);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
        }));
        it('Should fail to append canopy node with another payer authority', () => __awaiter(void 0, void 0, void 0, function* () {
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, another, [crypto.randomBytes(32)], 0);
            try {
                yield (0, utils_1.execute)(provider, [appendIx], [anotherKeyPair]);
                (0, node_assert_1.strict)(false, 'Appending with another payer should have failed');
            }
            catch (_a) { }
        }));
        it('Should fail to append canopy nodes over the limit', () => __awaiter(void 0, void 0, void 0, function* () {
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, Array.from({ length: 3 }, () => crypto.randomBytes(32)), 0);
            try {
                yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Appending over the limit should have failed');
            }
            catch (_a) { }
        }));
        it('Should fail to append canopy nodes over the limit starting from the last index', () => __awaiter(void 0, void 0, void 0, function* () {
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, Array.from({ length: 2 }, () => crypto.randomBytes(32)), 1);
            try {
                yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Appending over the limit should have failed');
            }
            catch (_a) { }
        }));
        it('Should fail to append 0 canopy nodes', () => __awaiter(void 0, void 0, void 0, function* () {
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [], 0);
            try {
                yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Appending 0 nodes should have failed');
            }
            catch (_a) { }
        }));
        it('Should fail to finalize the tree without canopy', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            try {
                yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Finalizing without canopy should have failed');
            }
            catch (_a) { }
        }));
        it('Should fail to finalize the tree with an incomplete canopy', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [merkleTreeRaw.leaves[0].parent.node], 0);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            try {
                yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Finalization for an incomplete canopy should have failed');
            }
            catch (_a) { }
        }));
        it('Should finalize the tree with a complete canopy', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            // take every second leaf and append it's parent node to the canopy
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves.filter((_, i) => i % 2 === 0).map(leaf => leaf.parent.node), 0);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            (0, concurrentMerkleTreeAccount_test_1.assertCMTProperties)(splCMT, depth, size, payer, root, canopyDepth, true);
        }));
        it('Should be able to setup canopy with several transactions', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            // take every second leaf of the first half of a tree and append it's parent node to the canopy
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves
                .slice(0, leaves.length / 2)
                .filter((_, i) => i % 2 === 0)
                .map(leaf => leaf.parent.node), 0);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            // take every second leaf of the second half of a tree and append it's parent node to the canopy
            const appendIx2 = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves
                .slice(leaves.length / 2)
                .filter((_, i) => i % 2 === 0)
                .map(leaf => leaf.parent.node), 2);
            yield (0, utils_1.execute)(provider, [appendIx2], [payerKeypair]);
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
        }));
        it('Should be able to setup canopy with several transactions in reverse order', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves
                .slice(leaves.length / 2)
                .filter((_, i) => i % 2 === 0)
                .map(leaf => leaf.parent.node), 2);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            const appendIx2 = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves
                .slice(0, leaves.length / 2)
                .filter((_, i) => i % 2 === 0)
                .map(leaf => leaf.parent.node), 0);
            yield (0, utils_1.execute)(provider, [appendIx2], [payerKeypair]);
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
        }));
        it('Should be able to replace a canopy node', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves
                .slice(0, leaves.length / 2)
                .filter((_, i) => i % 2 === 0)
                .map(leaf => leaf.parent.node), 0);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            const appendIx2 = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [crypto.randomBytes(32)], 2);
            yield (0, utils_1.execute)(provider, [appendIx2], [payerKeypair]);
            const replaceIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves
                .slice(leaves.length / 2)
                .filter((_, i) => i % 2 === 0)
                .map(leaf => leaf.parent.node), 2);
            yield (0, utils_1.execute)(provider, [replaceIx], [payerKeypair]);
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
        }));
        it('Should fail to replace a canopy node for a finalised tree', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves.filter((_, i) => i % 2 === 0).map(leaf => leaf.parent.node), 0);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
            const replaceIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [crypto.randomBytes(32)], 0);
            try {
                yield (0, utils_1.execute)(provider, [replaceIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Replacing a canopy node for a finalised tree should have failed');
            }
            catch (_a) { }
        }));
        it('Should fail to initialize an empty tree after preparing a tree', () => __awaiter(void 0, void 0, void 0, function* () {
            const ixs = [
                (0, src_1.createInitEmptyMerkleTreeIx)(cmt, payer, {
                    maxBufferSize: size,
                    maxDepth: depth,
                }),
            ];
            try {
                yield (0, utils_1.execute)(provider, ixs, [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Initializing an empty tree after preparing a tree should have failed');
            }
            catch (_a) { }
        }));
        it('Should be able to close a prepared tree after setting the canopy', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, merkleTreeRaw.leaves
                .slice(0, leaves.length / 2)
                .filter((_, i) => i % 2 === 0)
                .map(leaf => leaf.parent.node), 0);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            let payerInfo = yield provider.connection.getAccountInfo(payer, 'confirmed');
            let treeInfo = yield provider.connection.getAccountInfo(cmt, 'confirmed');
            const payerLamports = payerInfo.lamports;
            const treeLamports = treeInfo.lamports;
            const closeIx = (0, src_1.createCloseEmptyTreeIx)(cmt, payer, payer);
            yield (0, utils_1.execute)(provider, [closeIx], [payerKeypair]);
            payerInfo = yield provider.connection.getAccountInfo(payer, 'confirmed');
            const finalLamports = payerInfo.lamports;
            (0, node_assert_1.strict)(finalLamports === payerLamports + treeLamports - 5000, 'Expected payer to have received the lamports from the closed tree account');
            treeInfo = yield provider.connection.getAccountInfo(cmt, 'confirmed');
            (0, node_assert_1.strict)(treeInfo === null, 'Expected the merkle tree account info to be null');
        }));
    });
    describe('Having prepared an empty tree with canopy', () => {
        const depth = 3;
        const size = 8;
        const canopyDepth = 2;
        // empty leaves represent the empty tree
        const leaves = [
            Buffer.alloc(32),
            Buffer.alloc(32),
            Buffer.alloc(32),
            Buffer.alloc(32),
            Buffer.alloc(32),
            Buffer.alloc(32),
            Buffer.alloc(32),
            Buffer.alloc(32),
        ];
        let anotherKeyPair;
        let another;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            const cmtKeypair = yield (0, utils_1.prepareTree)({
                canopyDepth,
                depthSizePair: {
                    maxBufferSize: size,
                    maxDepth: depth,
                },
                payer: payerKeypair,
                provider,
            });
            cmt = cmtKeypair.publicKey;
            anotherKeyPair = web3_js_1.Keypair.generate();
            another = anotherKeyPair.publicKey;
            yield provider.connection.confirmTransaction(yield provider.connection.requestAirdrop(another, 1e10), 'confirmed');
        }));
        it('Should be able to finalize an empty tree with empty canopy and close it afterwards', () => __awaiter(void 0, void 0, void 0, function* () {
            const merkleTreeRaw = new merkle_tree_1.MerkleTree(leaves);
            const root = merkleTreeRaw.root;
            const leaf = leaves[leaves.length - 1];
            const finalize = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, root, leaf, leaves.length - 1, merkleTreeRaw.getProof(leaves.length - 1).proof);
            yield (0, utils_1.execute)(provider, [finalize], [payerKeypair]);
            let payerInfo = yield provider.connection.getAccountInfo(payer, 'confirmed');
            let treeInfo = yield provider.connection.getAccountInfo(cmt, 'confirmed');
            const payerLamports = payerInfo.lamports;
            const treeLamports = treeInfo.lamports;
            const closeIx = (0, src_1.createCloseEmptyTreeIx)(cmt, payer, payer);
            yield (0, utils_1.execute)(provider, [closeIx], [payerKeypair]);
            payerInfo = yield provider.connection.getAccountInfo(payer, 'confirmed');
            const finalLamports = payerInfo.lamports;
            (0, node_assert_1.strict)(finalLamports === payerLamports + treeLamports - 5000, 'Expected payer to have received the lamports from the closed tree account');
            treeInfo = yield provider.connection.getAccountInfo(cmt, 'confirmed');
            (0, node_assert_1.strict)(treeInfo === null, 'Expected the merkle tree account info to be null');
        }));
    });
    describe('Having created a tree with a single leaf', () => {
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, payerKeypair, 1, DEPTH_SIZE_PAIR);
            cmt = cmtKeypair.publicKey;
        }));
        it('Append single leaf', () => __awaiter(void 0, void 0, void 0, function* () {
            const newLeaf = crypto.randomBytes(32);
            const appendIx = (0, src_1.createAppendIx)(cmt, payer, newLeaf);
            yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            offChainTree.updateLeaf(1, newLeaf);
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            const onChainRoot = splCMT.getCurrentRoot();
            (0, node_assert_1.strict)(Buffer.from(onChainRoot).equals(offChainTree.root), 'Updated on chain root matches root of updated off chain tree');
        }));
        it('Verify proof works for that leaf', () => __awaiter(void 0, void 0, void 0, function* () {
            const newLeaf = crypto.randomBytes(32);
            const index = 0;
            const proof = offChainTree.getProof(index);
            const verifyLeafIx = (0, src_1.createVerifyLeafIx)(cmt, proof);
            const replaceLeafIx = (0, src_1.createReplaceIx)(cmt, payer, newLeaf, proof);
            yield (0, utils_1.execute)(provider, [verifyLeafIx, replaceLeafIx], [payerKeypair]);
            offChainTree.updateLeaf(index, newLeaf);
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            const onChainRoot = splCMT.getCurrentRoot();
            (0, node_assert_1.strict)(Buffer.from(onChainRoot).equals(offChainTree.root), 'Updated on chain root matches root of updated off chain tree');
        }));
        it('Verify leaf fails when proof fails', () => __awaiter(void 0, void 0, void 0, function* () {
            const newLeaf = crypto.randomBytes(32);
            const index = 0;
            // Replace valid proof with random bytes so it is wrong
            const proof = offChainTree.getProof(index);
            proof.proof = proof.proof.map(_ => {
                return crypto.randomBytes(32);
            });
            // Verify proof is invalid
            const verifyLeafIx = (0, src_1.createVerifyLeafIx)(cmt, proof);
            try {
                yield (0, utils_1.execute)(provider, [verifyLeafIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Proof should have failed to verify');
            }
            catch (_a) { }
            // Replace instruction with same proof fails
            const replaceLeafIx = (0, src_1.createReplaceIx)(cmt, payer, newLeaf, proof);
            try {
                yield (0, utils_1.execute)(provider, [replaceLeafIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Replace should have failed to verify');
            }
            catch (_b) { }
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmtKeypair.publicKey);
            const onChainRoot = splCMT.getCurrentRoot();
            (0, node_assert_1.strict)(Buffer.from(onChainRoot).equals(offChainTree.root), 'Updated on chain root matches root of updated off chain tree');
        }));
        it('Replace that leaf', () => __awaiter(void 0, void 0, void 0, function* () {
            const newLeaf = crypto.randomBytes(32);
            const index = 0;
            const replaceLeafIx = (0, src_1.createReplaceIx)(cmt, payer, newLeaf, offChainTree.getProof(index, false, -1));
            (0, node_assert_1.strict)(replaceLeafIx.keys.length == 3 + MAX_DEPTH, `Failed to create proof for ${MAX_DEPTH}`);
            yield (0, utils_1.execute)(provider, [replaceLeafIx], [payerKeypair]);
            offChainTree.updateLeaf(index, newLeaf);
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            const onChainRoot = splCMT.getCurrentRoot();
            (0, node_assert_1.strict)(Buffer.from(onChainRoot).equals(offChainTree.root), 'Updated on chain root matches root of updated off chain tree');
        }));
        it('Replace that leaf with a minimal proof', () => __awaiter(void 0, void 0, void 0, function* () {
            const newLeaf = crypto.randomBytes(32);
            const index = 0;
            const replaceLeafIx = (0, src_1.createReplaceIx)(cmt, payer, newLeaf, offChainTree.getProof(index, true, 1));
            (0, node_assert_1.strict)(replaceLeafIx.keys.length == 3 + 1, 'Failed to minimize proof to expected size of 1');
            yield (0, utils_1.execute)(provider, [replaceLeafIx], [payerKeypair]);
            offChainTree.updateLeaf(index, newLeaf);
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            const onChainRoot = splCMT.getCurrentRoot();
            (0, node_assert_1.strict)(Buffer.from(onChainRoot).equals(offChainTree.root), 'Updated on chain root matches root of updated off chain tree');
        }));
        it('Should fail to prepare a batch ready tree for an existing tree', () => __awaiter(void 0, void 0, void 0, function* () {
            const prepareIx = (0, src_1.prepareTreeIx)(cmt, payer, DEPTH_SIZE_PAIR);
            try {
                yield (0, utils_1.execute)(provider, [prepareIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Prepare a batch tree should have failed for the existing tree');
            }
            catch (_a) { }
        }));
        it('Should fail to finalize an existing tree', () => __awaiter(void 0, void 0, void 0, function* () {
            const index = offChainTree.leaves.length - 1;
            const finalizeIx = (0, src_1.createInitPreparedTreeWithRootIx)(cmt, payer, offChainTree.root, offChainTree.leaves[index].node, index, offChainTree.getProof(index).proof);
            try {
                yield (0, utils_1.execute)(provider, [finalizeIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Finalize an existing tree should have failed');
            }
            catch (_a) { }
        }));
    });
    describe('Examples transferring authority', () => {
        const authorityKeypair = web3_js_1.Keypair.generate();
        const authority = authorityKeypair.publicKey;
        const randomSignerKeypair = web3_js_1.Keypair.generate();
        const randomSigner = randomSignerKeypair.publicKey;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            yield provider.connection.confirmTransaction(yield connection.requestAirdrop(authority, 1e10));
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, authorityKeypair, 1, DEPTH_SIZE_PAIR);
            cmt = cmtKeypair.publicKey;
        }));
        it('Attempting to replace with random authority fails', () => __awaiter(void 0, void 0, void 0, function* () {
            const newLeaf = crypto.randomBytes(32);
            const replaceIndex = 0;
            const proof = offChainTree.getProof(replaceIndex);
            const replaceIx = (0, src_1.createReplaceIx)(cmt, randomSigner, newLeaf, proof);
            try {
                yield (0, utils_1.execute)(provider, [replaceIx], [randomSignerKeypair]);
                (0, node_assert_1.strict)(false, 'Transaction should have failed since incorrect authority cannot execute replaces');
            }
            catch (_a) { }
        }));
        it('Can transfer authority', () => __awaiter(void 0, void 0, void 0, function* () {
            const transferAuthorityIx = (0, src_1.createTransferAuthorityIx)(cmt, authority, randomSigner);
            yield (0, utils_1.execute)(provider, [transferAuthorityIx], [authorityKeypair]);
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            (0, node_assert_1.strict)(splCMT.getAuthority().equals(randomSigner), `Upon transferring authority, authority should be ${randomSigner.toString()}, but was instead updated to ${splCMT.getAuthority()}`);
            // Attempting to replace with new authority now works
            const newLeaf = crypto.randomBytes(32);
            const replaceIndex = 0;
            const proof = offChainTree.getProof(replaceIndex);
            const replaceIx = (0, src_1.createReplaceIx)(cmt, randomSigner, newLeaf, proof);
            yield (0, utils_1.execute)(provider, [replaceIx], [randomSignerKeypair]);
        }));
    });
    describe(`Having created a tree with ${MAX_SIZE} leaves`, () => {
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, payerKeypair, MAX_SIZE, DEPTH_SIZE_PAIR);
            cmt = cmtKeypair.publicKey;
        }));
        it(`Replace all of them in a block`, () => __awaiter(void 0, void 0, void 0, function* () {
            // Replace 64 leaves before syncing off-chain tree with on-chain tree
            const ixArray = [];
            const txList = [];
            const leavesToUpdate = [];
            for (let i = 0; i < MAX_SIZE; i++) {
                const index = i;
                const newLeaf = (0, merkle_tree_1.hash)(payer.toBuffer(), Buffer.from(new bn_js_1.BN(i).toArray()));
                leavesToUpdate.push(newLeaf);
                const proof = offChainTree.getProof(index);
                const replaceIx = (0, src_1.createReplaceIx)(cmt, payer, newLeaf, proof);
                ixArray.push(replaceIx);
            }
            // Execute all replaces
            ixArray.map(ix => {
                txList.push((0, utils_1.execute)(provider, [ix], [payerKeypair]));
            });
            yield Promise.all(txList);
            leavesToUpdate.map((leaf, index) => {
                offChainTree.updateLeaf(index, leaf);
            });
            // Compare on-chain & off-chain roots
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            const onChainRoot = splCMT.getCurrentRoot();
            (0, node_assert_1.strict)(Buffer.from(onChainRoot).equals(offChainTree.root), 'Updated on chain root does not match root of updated off chain tree');
        }));
        it('Empty all of the leaves and close the tree', () => __awaiter(void 0, void 0, void 0, function* () {
            const ixArray = [];
            const txList = [];
            const leavesToUpdate = [];
            for (let i = 0; i < MAX_SIZE; i++) {
                const index = i;
                const newLeaf = (0, merkle_tree_1.hash)(payer.toBuffer(), Buffer.from(new bn_js_1.BN(i).toArray()));
                leavesToUpdate.push(newLeaf);
                const proof = offChainTree.getProof(index);
                const replaceIx = (0, src_1.createReplaceIx)(cmt, payer, Buffer.alloc(32), proof);
                ixArray.push(replaceIx);
            }
            // Execute all replaces
            ixArray.map(ix => {
                txList.push((0, utils_1.execute)(provider, [ix], [payerKeypair]));
            });
            yield Promise.all(txList);
            let payerInfo = yield provider.connection.getAccountInfo(payer, 'confirmed');
            let treeInfo = yield provider.connection.getAccountInfo(cmt, 'confirmed');
            const payerLamports = payerInfo.lamports;
            const treeLamports = treeInfo.lamports;
            const ix = (0, src_1.createCloseEmptyTreeInstruction)({
                authority: payer,
                merkleTree: cmt,
                recipient: payer,
            });
            yield (0, utils_1.execute)(provider, [ix], [payerKeypair]);
            payerInfo = yield provider.connection.getAccountInfo(payer, 'confirmed');
            const finalLamports = payerInfo.lamports;
            (0, node_assert_1.strict)(finalLamports === payerLamports + treeLamports - 5000, 'Expected payer to have received the lamports from the closed tree account');
            treeInfo = yield provider.connection.getAccountInfo(cmt, 'confirmed');
            (0, node_assert_1.strict)(treeInfo === null, 'Expected the merkle tree account info to be null');
        }));
        it('It cannot be closed until empty', () => __awaiter(void 0, void 0, void 0, function* () {
            const ix = (0, src_1.createCloseEmptyTreeInstruction)({
                authority: payer,
                merkleTree: cmt,
                recipient: payer,
            });
            try {
                yield (0, utils_1.execute)(provider, [ix], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Closing a tree account before it is empty should ALWAYS error');
            }
            catch (_a) { }
        }));
    });
    describe(`Having created a tree with depth 3`, () => {
        const DEPTH = 3;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, payerKeypair, 0, {
                maxBufferSize: 8,
                maxDepth: DEPTH,
            });
            cmt = cmtKeypair.publicKey;
            for (let i = 0; i < 2 ** DEPTH; i++) {
                const newLeaf = Array.from(Buffer.alloc(32, i + 1));
                const appendIx = (0, src_1.createAppendIx)(cmt, payer, newLeaf);
                yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
            }
            // Compare on-chain & off-chain roots
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            (0, node_assert_1.strict)(splCMT.getBufferSize() === 2 ** DEPTH, 'Not all changes were processed');
            (0, node_assert_1.strict)(splCMT.getCurrentBufferIndex() === 0, 'Not all changes were processed');
        }));
        it('Random attacker fails to fake the existence of a leaf by autocompleting proof', () => __awaiter(void 0, void 0, void 0, function* () {
            const maliciousLeafHash = crypto.randomBytes(32);
            const maliciousLeafHash1 = crypto.randomBytes(32);
            const nodeProof = [];
            for (let i = 0; i < DEPTH; i++) {
                nodeProof.push(Buffer.alloc(32));
            }
            // Root - make this nonsense so it won't match what's in ChangeLog, thus forcing proof autocompletion
            const replaceIx = (0, src_1.createReplaceIx)(cmt, payer, maliciousLeafHash1, {
                leaf: maliciousLeafHash,
                leafIndex: 0,
                proof: nodeProof,
                root: Buffer.alloc(32),
            });
            try {
                yield (0, utils_1.execute)(provider, [replaceIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Attacker was able to successfully write fake existence of a leaf');
            }
            catch (_a) { }
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            (0, node_assert_1.strict)(splCMT.getCurrentBufferIndex() === 0, "CMT updated its active index after attacker's transaction, when it shouldn't have done anything");
        }));
    });
    describe(`Canopy test`, () => {
        const DEPTH = 5;
        it(`Testing canopy for verify leaf instructions`, () => __awaiter(void 0, void 0, void 0, function* () {
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, payerKeypair, 2 ** DEPTH, { maxBufferSize: 8, maxDepth: DEPTH }, DEPTH);
            cmt = cmtKeypair.publicKey;
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt, 'confirmed');
            let i = 0;
            const stepSize = 4;
            while (i < 2 ** DEPTH) {
                const ixs = [];
                for (let j = 0; j < stepSize; j += 1) {
                    const leafIndex = i + j;
                    const leaf = offChainTree.leaves[leafIndex].node;
                    const verifyIx = (0, src_1.createVerifyLeafIx)(cmt, {
                        leaf,
                        leafIndex,
                        proof: [],
                        root: splCMT.getCurrentRoot(),
                    });
                    ixs.push(verifyIx);
                }
                i += stepSize;
                yield (0, utils_1.execute)(provider, ixs, [payerKeypair]);
            }
        }));
        it('Testing canopy for appends and replaces on a full on chain tree', () => __awaiter(void 0, void 0, void 0, function* () {
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, payerKeypair, 0, { maxBufferSize: 8, maxDepth: DEPTH }, DEPTH);
            cmt = cmtKeypair.publicKey;
            // Test that the canopy updates properly throughout multiple modifying instructions
            // in the same transaction
            const leaves = [];
            let i = 0;
            const stepSize = 4;
            while (i < 2 ** DEPTH) {
                const ixs = [];
                for (let j = 0; j < stepSize; ++j) {
                    const newLeaf = Array.from(Buffer.alloc(32, i + 1));
                    leaves.push(newLeaf);
                    const appendIx = (0, src_1.createAppendIx)(cmt, payer, newLeaf);
                    ixs.push(appendIx);
                }
                yield (0, utils_1.execute)(provider, ixs, [payerKeypair]);
                i += stepSize;
                console.log('Appended', i, 'leaves');
            }
            // Compare on-chain & off-chain roots
            let ixs = [];
            const splCMT = yield src_1.ConcurrentMerkleTreeAccount.fromAccountAddress(connection, cmt);
            const root = splCMT.getCurrentRoot();
            // Test that the entire state of the tree is stored properly
            // by using the canopy to infer proofs to all of the leaves in the tree.
            // We test that the canopy is updating properly by replacing all the leaves
            // in the tree
            const leafList = Array.from(leaves.entries());
            leafList.sort(() => Math.random() - 0.5);
            let replaces = 0;
            const newLeaves = {};
            for (const [i, leaf] of leafList) {
                const newLeaf = crypto.randomBytes(32);
                newLeaves[i] = newLeaf;
                const replaceIx = (0, src_1.createReplaceIx)(cmt, payer, newLeaf, {
                    leaf: Buffer.from(Uint8Array.from(leaf)),
                    leafIndex: i,
                    proof: [],
                    root, // No proof necessary
                });
                ixs.push(replaceIx);
                if (ixs.length == stepSize) {
                    replaces++;
                    yield (0, utils_1.execute)(provider, ixs, [payerKeypair]);
                    console.log('Replaced', replaces * stepSize, 'leaves');
                    ixs = [];
                }
            }
            const newLeafList = [];
            for (let i = 0; i < 32; ++i) {
                newLeafList.push(newLeaves[i]);
            }
            const tree = new merkle_tree_1.MerkleTree(newLeafList);
            for (let proofSize = 1; proofSize <= 5; ++proofSize) {
                const newLeaf = crypto.randomBytes(32);
                const i = Math.floor(Math.random() * 32);
                const leaf = newLeaves[i];
                let proof = tree.getProof(i);
                const partialProof = proof.proof.slice(0, proofSize);
                // Create an instruction to replace the leaf
                const replaceIx = (0, src_1.createReplaceIx)(cmt, payer, newLeaf, Object.assign(Object.assign({}, proof), { proof: partialProof }));
                tree.updateLeaf(i, newLeaf);
                // Create an instruction to undo the previous replace, but using the now-outdated partialProof
                proof = tree.getProof(i);
                const replaceBackIx = (0, src_1.createReplaceIx)(cmt, payer, leaf, Object.assign(Object.assign({}, proof), { proof: partialProof }));
                tree.updateLeaf(i, leaf);
                yield (0, utils_1.execute)(provider, [replaceIx, replaceBackIx], [payerKeypair], true, true);
            }
        }));
        it('Should fail to append a canopy node for an existing tree', () => __awaiter(void 0, void 0, void 0, function* () {
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, payerKeypair, 0, { maxBufferSize: 8, maxDepth: DEPTH }, DEPTH);
            cmt = cmtKeypair.publicKey;
            const appendIx = (0, src_1.createAppendCanopyNodesIx)(cmt, payer, [crypto.randomBytes(32)], 0);
            try {
                yield (0, utils_1.execute)(provider, [appendIx], [payerKeypair]);
                (0, node_assert_1.strict)(false, 'Appending a canopy node for an existing tree should have failed');
            }
            catch (_a) { }
        }));
    });
    describe(`Having created a tree with 8 leaves`, () => {
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            [cmtKeypair, offChainTree] = yield (0, utils_1.createTreeOnChain)(provider, payerKeypair, 1 << 3, {
                maxBufferSize: 8,
                maxDepth: 3,
            });
            cmt = cmtKeypair.publicKey;
        }));
        it(`Attempt to replace a leaf beyond the tree's capacity`, () => __awaiter(void 0, void 0, void 0, function* () {
            // Ensure that this fails
            const outOfBoundsIndex = 8;
            const index = outOfBoundsIndex;
            const newLeaf = (0, merkle_tree_1.hash)(payer.toBuffer(), Buffer.from(new bn_js_1.BN(outOfBoundsIndex).toArray()));
            const node = offChainTree.leaves[outOfBoundsIndex - 1].node;
            const proof = offChainTree.getProof(index - 1).proof;
            const replaceIx = (0, src_1.createReplaceIx)(cmt, payer, newLeaf, {
                leaf: node,
                leafIndex: index,
                proof,
                root: offChainTree.root,
            });
            try {
                yield (0, utils_1.execute)(provider, [replaceIx], [payerKeypair]);
                throw Error('This replace instruction should have failed because the leaf index is OOB');
            }
            catch (_a) { }
        }));
    });
});
//# sourceMappingURL=accountCompression.test.js.map